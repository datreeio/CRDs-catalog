{
  "description": "ServiceIntegration is the Schema for the serviceintegrations API",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "ServiceIntegrationSpec defines the desired state of ServiceIntegration",
      "properties": {
        "authSecretRef": {
          "description": "Authentication reference to Aiven token in a secret",
          "properties": {
            "key": {
              "minLength": 1,
              "type": "string"
            },
            "name": {
              "minLength": 1,
              "type": "string"
            }
          },
          "required": [
            "key",
            "name"
          ],
          "type": "object",
          "additionalProperties": false
        },
        "clickhouseKafka": {
          "description": "Clickhouse Kafka configuration values",
          "properties": {
            "tables": {
              "description": "Tables to create",
              "items": {
                "description": "Table to create",
                "properties": {
                  "auto_offset_reset": {
                    "description": "Action to take when there is no initial offset in offset store or the desired offset is out of range",
                    "enum": [
                      "smallest",
                      "earliest",
                      "beginning",
                      "largest",
                      "latest",
                      "end"
                    ],
                    "type": "string"
                  },
                  "columns": {
                    "description": "Table columns",
                    "items": {
                      "description": "Table column",
                      "properties": {
                        "name": {
                          "description": "Column name",
                          "maxLength": 40,
                          "minLength": 1,
                          "type": "string"
                        },
                        "type": {
                          "description": "Column type",
                          "maxLength": 1000,
                          "minLength": 1,
                          "type": "string"
                        }
                      },
                      "required": [
                        "name",
                        "type"
                      ],
                      "type": "object",
                      "additionalProperties": false
                    },
                    "maxItems": 100,
                    "type": "array"
                  },
                  "data_format": {
                    "description": "Message data format",
                    "enum": [
                      "Avro",
                      "CSV",
                      "JSONAsString",
                      "JSONCompactEachRow",
                      "JSONCompactStringsEachRow",
                      "JSONEachRow",
                      "JSONStringsEachRow",
                      "MsgPack",
                      "TSKV",
                      "TSV",
                      "TabSeparated",
                      "RawBLOB",
                      "AvroConfluent",
                      "Parquet"
                    ],
                    "type": "string"
                  },
                  "date_time_input_format": {
                    "description": "Method to read DateTime from text input formats",
                    "enum": [
                      "basic",
                      "best_effort",
                      "best_effort_us"
                    ],
                    "type": "string"
                  },
                  "group_name": {
                    "description": "Kafka consumers group",
                    "maxLength": 249,
                    "minLength": 1,
                    "type": "string"
                  },
                  "handle_error_mode": {
                    "description": "How to handle errors for Kafka engine",
                    "enum": [
                      "default",
                      "stream"
                    ],
                    "type": "string"
                  },
                  "max_block_size": {
                    "description": "Number of row collected by poll(s) for flushing data from Kafka",
                    "maximum": 1000000000,
                    "minimum": 0,
                    "type": "integer"
                  },
                  "max_rows_per_message": {
                    "description": "The maximum number of rows produced in one kafka message for row-based formats",
                    "maximum": 1000000000,
                    "minimum": 1,
                    "type": "integer"
                  },
                  "name": {
                    "description": "Name of the table",
                    "maxLength": 40,
                    "minLength": 1,
                    "type": "string"
                  },
                  "num_consumers": {
                    "description": "The number of consumers per table per replica",
                    "maximum": 10,
                    "minimum": 1,
                    "type": "integer"
                  },
                  "poll_max_batch_size": {
                    "description": "Maximum amount of messages to be polled in a single Kafka poll",
                    "maximum": 1000000000,
                    "minimum": 0,
                    "type": "integer"
                  },
                  "skip_broken_messages": {
                    "description": "Skip at least this number of broken messages from Kafka topic per block",
                    "maximum": 1000000000,
                    "minimum": 0,
                    "type": "integer"
                  },
                  "topics": {
                    "description": "Kafka topics",
                    "items": {
                      "description": "Kafka topic",
                      "properties": {
                        "name": {
                          "description": "Name of the topic",
                          "maxLength": 249,
                          "minLength": 1,
                          "type": "string"
                        }
                      },
                      "required": [
                        "name"
                      ],
                      "type": "object",
                      "additionalProperties": false
                    },
                    "maxItems": 100,
                    "type": "array"
                  }
                },
                "required": [
                  "columns",
                  "data_format",
                  "group_name",
                  "name",
                  "topics"
                ],
                "type": "object",
                "additionalProperties": false
              },
              "maxItems": 100,
              "type": "array"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "clickhousePostgresql": {
          "description": "Clickhouse PostgreSQL configuration values",
          "properties": {
            "databases": {
              "description": "Databases to expose",
              "items": {
                "description": "Database to expose",
                "properties": {
                  "database": {
                    "description": "PostgreSQL database to expose",
                    "maxLength": 63,
                    "minLength": 1,
                    "type": "string"
                  },
                  "schema": {
                    "description": "PostgreSQL schema to expose",
                    "maxLength": 63,
                    "minLength": 1,
                    "type": "string"
                  }
                },
                "type": "object",
                "additionalProperties": false
              },
              "maxItems": 10,
              "type": "array"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "datadog": {
          "description": "Datadog specific user configuration options",
          "properties": {
            "datadog_dbm_enabled": {
              "description": "Enable Datadog Database Monitoring",
              "type": "boolean"
            },
            "datadog_pgbouncer_enabled": {
              "description": "Enable Datadog PgBouncer Metric Tracking",
              "type": "boolean"
            },
            "datadog_tags": {
              "description": "Custom tags provided by user",
              "items": {
                "description": "Datadog tag defined by user",
                "properties": {
                  "comment": {
                    "description": "Optional tag explanation",
                    "maxLength": 1024,
                    "type": "string"
                  },
                  "tag": {
                    "description": "Tag format and usage are described here: https://docs.datadoghq.com/getting_started/tagging. Tags with prefix 'aiven-' are reserved for Aiven.",
                    "maxLength": 200,
                    "minLength": 1,
                    "type": "string"
                  }
                },
                "required": [
                  "tag"
                ],
                "type": "object",
                "additionalProperties": false
              },
              "maxItems": 32,
              "type": "array"
            },
            "exclude_consumer_groups": {
              "description": "List of custom metrics",
              "items": {
                "type": "string"
              },
              "maxItems": 1024,
              "type": "array"
            },
            "exclude_topics": {
              "description": "List of topics to exclude",
              "items": {
                "type": "string"
              },
              "maxItems": 1024,
              "type": "array"
            },
            "include_consumer_groups": {
              "description": "List of custom metrics",
              "items": {
                "type": "string"
              },
              "maxItems": 1024,
              "type": "array"
            },
            "include_topics": {
              "description": "List of topics to include",
              "items": {
                "type": "string"
              },
              "maxItems": 1024,
              "type": "array"
            },
            "kafka_custom_metrics": {
              "description": "List of custom metrics",
              "items": {
                "type": "string"
              },
              "maxItems": 1024,
              "type": "array"
            },
            "max_jmx_metrics": {
              "description": "Maximum number of JMX metrics to send",
              "maximum": 100000,
              "minimum": 10,
              "type": "integer"
            },
            "mirrormaker_custom_metrics": {
              "description": "List of custom metrics",
              "items": {
                "type": "string"
              },
              "maxItems": 1024,
              "type": "array"
            },
            "opensearch": {
              "description": "Datadog Opensearch Options",
              "properties": {
                "cluster_stats_enabled": {
                  "description": "Enable Datadog Opensearch Cluster Monitoring",
                  "type": "boolean"
                },
                "index_stats_enabled": {
                  "description": "Enable Datadog Opensearch Index Monitoring",
                  "type": "boolean"
                },
                "pending_task_stats_enabled": {
                  "description": "Enable Datadog Opensearch Pending Task Monitoring",
                  "type": "boolean"
                },
                "pshard_stats_enabled": {
                  "description": "Enable Datadog Opensearch Primary Shard Monitoring",
                  "type": "boolean"
                }
              },
              "type": "object",
              "additionalProperties": false
            },
            "redis": {
              "description": "Datadog Redis Options",
              "properties": {
                "command_stats_enabled": {
                  "description": "Enable command_stats option in the agent's configuration",
                  "type": "boolean"
                }
              },
              "type": "object",
              "additionalProperties": false
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "destinationEndpointId": {
          "description": "Destination endpoint for the integration (if any)",
          "maxLength": 36,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "destinationProjectName": {
          "description": "Destination project for the integration (if any)",
          "maxLength": 63,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "destinationServiceName": {
          "description": "Destination service for the integration (if any)",
          "maxLength": 64,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "externalAWSCloudwatchMetrics": {
          "description": "External AWS CloudWatch Metrics integration Logs configuration values",
          "properties": {
            "dropped_metrics": {
              "description": "Metrics to not send to AWS CloudWatch (takes precedence over extra_metrics)",
              "items": {
                "description": "Metric name and subfield",
                "properties": {
                  "field": {
                    "description": "Identifier of a value in the metric",
                    "maxLength": 1000,
                    "type": "string"
                  },
                  "metric": {
                    "description": "Identifier of the metric",
                    "maxLength": 1000,
                    "type": "string"
                  }
                },
                "required": [
                  "field",
                  "metric"
                ],
                "type": "object",
                "additionalProperties": false
              },
              "maxItems": 1024,
              "type": "array"
            },
            "extra_metrics": {
              "description": "Metrics to allow through to AWS CloudWatch (in addition to default metrics)",
              "items": {
                "description": "Metric name and subfield",
                "properties": {
                  "field": {
                    "description": "Identifier of a value in the metric",
                    "maxLength": 1000,
                    "type": "string"
                  },
                  "metric": {
                    "description": "Identifier of the metric",
                    "maxLength": 1000,
                    "type": "string"
                  }
                },
                "required": [
                  "field",
                  "metric"
                ],
                "type": "object",
                "additionalProperties": false
              },
              "maxItems": 1024,
              "type": "array"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "integrationType": {
          "description": "Type of the service integration accepted by Aiven API. Some values may not be supported by the operator",
          "enum": [
            "alertmanager",
            "autoscaler",
            "caching",
            "cassandra_cross_service_cluster",
            "clickhouse_kafka",
            "clickhouse_postgresql",
            "dashboard",
            "datadog",
            "datasource",
            "external_aws_cloudwatch_logs",
            "external_aws_cloudwatch_metrics",
            "external_elasticsearch_logs",
            "external_google_cloud_logging",
            "external_opensearch_logs",
            "flink",
            "flink_external_kafka",
            "flink_external_postgresql",
            "internal_connectivity",
            "jolokia",
            "kafka_connect",
            "kafka_logs",
            "kafka_mirrormaker",
            "logs",
            "m3aggregator",
            "m3coordinator",
            "metrics",
            "opensearch_cross_cluster_replication",
            "opensearch_cross_cluster_search",
            "prometheus",
            "read_replica",
            "rsyslog",
            "schema_registry_proxy",
            "stresstester",
            "thanosquery",
            "thanosstore",
            "vmalert"
          ],
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "kafkaConnect": {
          "description": "Kafka Connect service configuration values",
          "properties": {
            "kafka_connect": {
              "description": "Kafka Connect service configuration values",
              "properties": {
                "config_storage_topic": {
                  "description": "The name of the topic where connector and task configuration data are stored.This must be the same for all workers with the same group_id.",
                  "maxLength": 249,
                  "type": "string"
                },
                "group_id": {
                  "description": "A unique string that identifies the Connect cluster group this worker belongs to.",
                  "maxLength": 249,
                  "type": "string"
                },
                "offset_storage_topic": {
                  "description": "The name of the topic where connector and task configuration offsets are stored.This must be the same for all workers with the same group_id.",
                  "maxLength": 249,
                  "type": "string"
                },
                "status_storage_topic": {
                  "description": "The name of the topic where connector and task configuration status updates are stored.This must be the same for all workers with the same group_id.",
                  "maxLength": 249,
                  "type": "string"
                }
              },
              "type": "object",
              "additionalProperties": false
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "kafkaLogs": {
          "description": "Kafka logs configuration values",
          "properties": {
            "kafka_topic": {
              "description": "Topic name",
              "maxLength": 249,
              "minLength": 1,
              "type": "string"
            },
            "selected_log_fields": {
              "description": "The list of logging fields that will be sent to the integration logging service. The MESSAGE and timestamp fields are always sent.",
              "items": {
                "type": "string"
              },
              "maxItems": 5,
              "type": "array"
            }
          },
          "required": [
            "kafka_topic"
          ],
          "type": "object",
          "additionalProperties": false
        },
        "kafkaMirrormaker": {
          "description": "Kafka MirrorMaker configuration values",
          "properties": {
            "cluster_alias": {
              "description": "The alias under which the Kafka cluster is known to MirrorMaker. Can contain the following symbols: ASCII alphanumerics, '.', '_', and '-'.",
              "maxLength": 128,
              "pattern": "^[a-zA-Z0-9_.-]+$",
              "type": "string"
            },
            "kafka_mirrormaker": {
              "description": "Kafka MirrorMaker configuration values",
              "properties": {
                "consumer_auto_offset_reset": {
                  "description": "Set where consumer starts to consume data. Value `earliest`: Start replication from the earliest offset. Value `latest`: Start replication from the latest offset. Default is `earliest`.",
                  "enum": [
                    "earliest",
                    "latest"
                  ],
                  "type": "string"
                },
                "consumer_fetch_min_bytes": {
                  "description": "The minimum amount of data the server should return for a fetch request",
                  "maximum": 5242880,
                  "minimum": 1,
                  "type": "integer"
                },
                "consumer_max_poll_records": {
                  "description": "Set consumer max.poll.records. The default is 500.",
                  "maximum": 20000,
                  "minimum": 100,
                  "type": "integer"
                },
                "producer_batch_size": {
                  "description": "The batch size in bytes producer will attempt to collect before publishing to broker.",
                  "maximum": 5242880,
                  "minimum": 0,
                  "type": "integer"
                },
                "producer_buffer_memory": {
                  "description": "The amount of bytes producer can use for buffering data before publishing to broker.",
                  "maximum": 134217728,
                  "minimum": 5242880,
                  "type": "integer"
                },
                "producer_compression_type": {
                  "description": "Specify the default compression type for producers. This configuration accepts the standard compression codecs ('gzip', 'snappy', 'lz4', 'zstd'). It additionally accepts 'none' which is the default and equivalent to no compression.",
                  "enum": [
                    "gzip",
                    "snappy",
                    "lz4",
                    "zstd",
                    "none"
                  ],
                  "type": "string"
                },
                "producer_linger_ms": {
                  "description": "The linger time (ms) for waiting new data to arrive for publishing.",
                  "maximum": 5000,
                  "minimum": 0,
                  "type": "integer"
                },
                "producer_max_request_size": {
                  "description": "The maximum request size in bytes.",
                  "maximum": 268435456,
                  "minimum": 0,
                  "type": "integer"
                }
              },
              "type": "object",
              "additionalProperties": false
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "logs": {
          "description": "Logs configuration values",
          "properties": {
            "elasticsearch_index_days_max": {
              "description": "Elasticsearch index retention limit",
              "maximum": 10000,
              "minimum": 1,
              "type": "integer"
            },
            "elasticsearch_index_prefix": {
              "description": "Elasticsearch index prefix",
              "maxLength": 1024,
              "minLength": 1,
              "type": "string"
            },
            "selected_log_fields": {
              "description": "The list of logging fields that will be sent to the integration logging service. The MESSAGE and timestamp fields are always sent.",
              "items": {
                "type": "string"
              },
              "maxItems": 5,
              "type": "array"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "metrics": {
          "description": "Metrics configuration values",
          "properties": {
            "database": {
              "description": "Name of the database where to store metric datapoints. Only affects PostgreSQL destinations. Defaults to 'metrics'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.",
              "maxLength": 40,
              "pattern": "^[_A-Za-z0-9][-_A-Za-z0-9]{0,39}$",
              "type": "string"
            },
            "retention_days": {
              "description": "Number of days to keep old metrics. Only affects PostgreSQL destinations. Set to 0 for no automatic cleanup. Defaults to 30 days.",
              "maximum": 10000,
              "minimum": 0,
              "type": "integer"
            },
            "ro_username": {
              "description": "Name of a user that can be used to read metrics. This will be used for Grafana integration (if enabled) to prevent Grafana users from making undesired changes. Only affects PostgreSQL destinations. Defaults to 'metrics_reader'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.",
              "maxLength": 40,
              "pattern": "^[_A-Za-z0-9][-._A-Za-z0-9]{0,39}$",
              "type": "string"
            },
            "source_mysql": {
              "description": "Configuration options for metrics where source service is MySQL",
              "properties": {
                "telegraf": {
                  "description": "Configuration options for Telegraf MySQL input plugin",
                  "properties": {
                    "gather_event_waits": {
                      "description": "Gather metrics from PERFORMANCE_SCHEMA.EVENT_WAITS",
                      "type": "boolean"
                    },
                    "gather_file_events_stats": {
                      "description": "gather metrics from PERFORMANCE_SCHEMA.FILE_SUMMARY_BY_EVENT_NAME",
                      "type": "boolean"
                    },
                    "gather_index_io_waits": {
                      "description": "Gather metrics from PERFORMANCE_SCHEMA.TABLE_IO_WAITS_SUMMARY_BY_INDEX_USAGE",
                      "type": "boolean"
                    },
                    "gather_info_schema_auto_inc": {
                      "description": "Gather auto_increment columns and max values from information schema",
                      "type": "boolean"
                    },
                    "gather_innodb_metrics": {
                      "description": "Gather metrics from INFORMATION_SCHEMA.INNODB_METRICS",
                      "type": "boolean"
                    },
                    "gather_perf_events_statements": {
                      "description": "Gather metrics from PERFORMANCE_SCHEMA.EVENTS_STATEMENTS_SUMMARY_BY_DIGEST",
                      "type": "boolean"
                    },
                    "gather_process_list": {
                      "description": "Gather thread state counts from INFORMATION_SCHEMA.PROCESSLIST",
                      "type": "boolean"
                    },
                    "gather_slave_status": {
                      "description": "Gather metrics from SHOW SLAVE STATUS command output",
                      "type": "boolean"
                    },
                    "gather_table_io_waits": {
                      "description": "Gather metrics from PERFORMANCE_SCHEMA.TABLE_IO_WAITS_SUMMARY_BY_TABLE",
                      "type": "boolean"
                    },
                    "gather_table_lock_waits": {
                      "description": "Gather metrics from PERFORMANCE_SCHEMA.TABLE_LOCK_WAITS",
                      "type": "boolean"
                    },
                    "gather_table_schema": {
                      "description": "Gather metrics from INFORMATION_SCHEMA.TABLES",
                      "type": "boolean"
                    },
                    "perf_events_statements_digest_text_limit": {
                      "description": "Truncates digest text from perf_events_statements into this many characters",
                      "maximum": 2048,
                      "minimum": 1,
                      "type": "integer"
                    },
                    "perf_events_statements_limit": {
                      "description": "Limits metrics from perf_events_statements",
                      "maximum": 4000,
                      "minimum": 1,
                      "type": "integer"
                    },
                    "perf_events_statements_time_limit": {
                      "description": "Only include perf_events_statements whose last seen is less than this many seconds",
                      "maximum": 2592000,
                      "minimum": 1,
                      "type": "integer"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "type": "object",
              "additionalProperties": false
            },
            "username": {
              "description": "Name of the user used to write metrics. Only affects PostgreSQL destinations. Defaults to 'metrics_writer'. Note that this must be the same for all metrics integrations that write data to the same PostgreSQL service.",
              "maxLength": 40,
              "pattern": "^[_A-Za-z0-9][-._A-Za-z0-9]{0,39}$",
              "type": "string"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "project": {
          "description": "Identifies the project this resource belongs to",
          "maxLength": 63,
          "pattern": "^[a-zA-Z0-9_-]+$",
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "sourceEndpointID": {
          "description": "Source endpoint for the integration (if any)",
          "maxLength": 36,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "sourceProjectName": {
          "description": "Source project for the integration (if any)",
          "maxLength": 63,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "sourceServiceName": {
          "description": "Source service for the integration (if any)",
          "maxLength": 64,
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        }
      },
      "required": [
        "integrationType",
        "project"
      ],
      "type": "object",
      "additionalProperties": false
    },
    "status": {
      "description": "ServiceIntegrationStatus defines the observed state of ServiceIntegration",
      "properties": {
        "conditions": {
          "description": "Conditions represent the latest available observations of an ServiceIntegration state",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource.\n---\nThis struct is intended for direct use as an array at the field path .status.conditions.  For example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the observations of a foo's current state.\n\t    // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"\n\t    // +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    // +listType=map\n\t    // +listMapKey=type\n\t    Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t    // other fields\n\t}",
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "format": "date-time",
                "type": "string"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "maxLength": 32768,
                "type": "string"
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "format": "int64",
                "minimum": 0,
                "type": "integer"
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
                "type": "string"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ],
                "type": "string"
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
                "type": "string"
              }
            },
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "type": "object",
            "additionalProperties": false
          },
          "type": "array"
        },
        "id": {
          "description": "Service integration ID",
          "type": "string"
        }
      },
      "required": [
        "conditions",
        "id"
      ],
      "type": "object",
      "additionalProperties": false
    }
  },
  "type": "object"
}
